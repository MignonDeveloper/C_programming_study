# 9. Memory & Pointer (2) - 동적 할당

## C언어 Memory 종류

> C언어에서 말하는 Memory는 기본적으로 **Virtual Memory(가상 메모리 체계)**를 의미한다.

- [가상 메모리란 무엇인가](https://l2men.tistory.com/21)

<br>

모든 메모리에 대해서는 **읽기/쓰기/실행에 해당하는 접근 permission**이 정해져있다.

**C언어에서 다루는 Memory Type**
- **Stack** : 1MB (default 크기)
    - **Scope, 지역변수, 자동변수**를 저장한다.
- **Heap** : 자유 메모리 영역
    - 크기가 제한되어 있지 않다.(32bit + single threading 일 시, 대략 1.7GB)
    - 나머지 모든 것들이 다 들어가있다. → **동적할당**
- **PE Image**
    - **Text :** user code
    - **Data**
        - RW-: 읽기와 쓰기가 가능한 영역 = **전역변수, 정적변수**가 저장됨.
        - R--: 읽기만 되는 영역 = **문자열 상수**가 저장됨.

<br>

## 동적할당
이전까지는 **변수를 선언 및 정의하는 방법**으로 메모리를 사용했다. 이와 같은 메모리 사용방식은 관리의 책임이 따르지 않는다. → 메모리를 할당하고 다시 운영체제에 반환하는 일련의 과정에 대해서 알아서 해주기 때문에 **자동변수**라고 부른다.

하지만, **메모리의 동적 할당 및 해제**는 다르다.
 - `malloc()`함수를 이용하면 자동변수와는 비교할 수도 없을 만큼 **자유롭게 Heap영역의 메모리를 다룰 수 있다**.
 - 게다가 **동적(Dynamic = Runtime)**으로 할 수 있다. 즉, 프로그램이 실행되는 도중에 대량의 메모리가 필요한 경우에도 할당이 가능하다.
 - 대신 `free()` 반환(해제)의 책임이 따른다!

<br>

메모리는 OS가 관리를 하는데, 내가 만든 프로그램에서 20MB짜리 사진을 로딩해야하는데 stack만으로는 그 메모리가 부족하므로, OS한테 <u>**(1)메모리를 요청** 하고, OS가 메모리 20MB를 **(2)사용할 수 있도록 허가**해준다. 다 쓰면 OS한테 **(3)다시 반납**해줘야 한다.</u>

- **`void * malloc(size_t size);`**
    - size = 할당 받을 메모리의 *byte* 단위 크기
    - 반환값 = Heap영역에 할당된 메모리 덩어리 중 **첫 번째 바이트 메모리의 주소**
        - 만약, 메모리를 할당하는데 **에러가 발생하면 NULL 값**을 반환
    - **할당받은 메모리는 반드시 free( void * ) 함수를 이용하여 반환**해야 하며, **메모리를 초기화하려면 `memset()` 함수를 이용** 
    (할당 받으면 기본적으로 메모리안에 쓰레기값이 들어있다.)
- **`free(void *memory_address)`**
    - **반환 해줘야 하는 메모리의 크기를 알아서 처리해준다!**
    - 동적 할당 된 **메모리는** `cd`로 채워지고, 그 **앞뒤로** `fd`**가 4byte씩** 채워져있다.
        - free 함수를 call 할 때 할당받을 메모리의 영역을 넘어가는 부분에 다른 것으로 채워져 있으면 memory overflow로 판단.
        - 즉, fd의 역할은 **memory overflow를 catch하기 위한 바리게이트 역할** (유사하게, 변수를 선언하면 stack 메모리에는 선언된 영역만큼 `cc`로 채워진다.)

```cpp
int *pList = NULL;
pList = malloc(sizeof(int) * 3);
free(pList)
```

1. `sizeof(int) * 3`: "int[3]의 자료형으로 쓰겠다"는 의도적 표현
2. 메모리 사용을 다 했으면, **반드시** `free()`**를 통해서 OS에 반환**해준다.(Memory Leakage 방지)

<br>

## 메모리 관리의 측면에서 본 동적할당

> Max Heap 자료구조로 관리

처음에 100byte가 필요해서 허가를 받은 후 chunk 단위의 메모리를 할당 받음
→ 다 써서 다시 100byte 만큼을 OS한테 반납
→ 이후 95byte가 필요하다고 요구할 시, **메모리 chunk를 새로 자르는 것 보다는, 100byte chunk를 다시 빌려주는 방식**을 택한다.

`malloc()`은 메모리를 확보하는데 속도가 조금 떨어진다. 따라서 고성능 프로그램을 만들 때에는 한번에 500MB가량을 확보해서 메모리 풀을 한번에 확보하여 속도를 빠르게 만들어 준다.

<br>

## 메모리 초기화 및 사용

메모리는 OS로부터 빌려오는 것이기 때문에, 안에 어떤 정보가 담겨 있을지 알 수 없다. **따라서, 사용자가 0으로 초기화 하는 것이 기본**

**(1) `memset()` 활용**

```cpp
#include <stdio.h>
#include <stdlib.h>

int main(void){
	int *pList = NULL;	
	pList = malloc(sizeof(int) * 3); 
	memset(pList, 0, sizeof(int) * 3);
	free(pList);
	return 0;
}
```

**(2) `void * calloc(size_t num, size_t size);` 활용**

- `num` : 요소의 개수 = 자료형의 개수
- `size` : 각 요소의 바이트 단위 크기 = `sizeof()`
- **반환 값** : Heap 영역에 할당된 메모리 덩어리 중 첫 번째 바이트 메모리의 주소
- `malloc()`과 달리 **할당받은 메모리를 모두 0으로 초기화하여 전달**

**(3) 동적 할당된 메모리 크기 확인** → `int _msize(void*)`