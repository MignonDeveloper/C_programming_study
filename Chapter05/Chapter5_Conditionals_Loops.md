# 5. Conditionals & Loops


## 제어문

> 프로그램의 흐름(연산이 진행되는 순서)을 변경하는 구문

- `if`, `else if`, `else`

<br>

## 식별자 검색순서

**Block Scope**: 여러 구문을 한 덩어리로 묶어주는 역할과 범위를 제한하는 역할

- 변수의 통용범위는 **해당 변수를 선언한 Block Scope로 제한** → **Stack**을 통해 식별자가 무엇을 가리키는지 파악 가능
- 지역변수 & 자동변수는 스코프를 벗어나면 사라진다.
    - 한 Block Scope 내에서 식별자의 이름은 유일해야 한다.
    - 반대로, 속한 Block Scope를 벗어나서 외부/내부/다른 곳의 Block Scope 에서는 이름 중복 가능

<br>

## Refactoring View in - Multiple If, Switch-Case, Goto

Refactoring의 관점에서 봤을 때, 다중 if 와 switch-case 구문은 사용을 자제하는 것이 좋다.

따라서 이를 대체하기 위해 **Lookup-Table**을 사용한다.

- <u>각 address의 index에 의미를 부여</u>하여, 해당하는 index에 해당하는 값을 넣어서 필요한 값을 O(1) 만에 바로 찾아내는 방법
- 메모리만 조금 쓰고, 연산을 딱 한 번만 하면 되므로 매우 간단하고 빠른방법

`goto`는 Evil Code라고 불린다! Error처리를 하는 경우를 제외하고 절대로 사용하지 말 것! (흐름을 꼬여버리게 만든다.)

<br>

## 반복문

> 일정구간의 코드를 연속적으로 반복해 실행하는 제어문

if문과 거의 차이가 없으며, 단순히 조건이 맞으면 block scope 내에 있는 절차적 흐름을 여러 번 반복 시행한다.

- **초기화** (계수기 변수 선언) / **조건식** / **반복하는 부분** (종료조건에 도달하도록 계수기 증가)
- `while` / `for` / `do-while`

**단, 반복문 내부에 변수를 선언하는 것은 바람직하지 않다.**

Stack의 관점에서 바라보면, 선언된 변수를 계속 stack에 push하고 한 번의 흐름이 끝나면 다시 pop 하는 과정을 거친다. 즉, 메모리 낭비가 심해지므로 성능 측면에서 매우 비효율적

<br>

## break & continue

- `break`: 즉시 반복문을 탈출하고 반복문 다음의 구문으로 넘어간다
- `continue`: 반복문을 탈출하지는 않고, 다시 조건을 비교하러 올라간다.
    - 상황에 따라 다르겠지만 흐름의 복잡도 측면에서 continue는 안좋을 수 있으므로 주의