# 4. Operators


C언어는 **Item**(항)과 **Operator**(연산자) → **Statement**(구문) → **Block Scope**으로 구성되어 표현되며 **Context**(절차적 흐름)에 따라 연산을 진행한다.

이 Block Scope가 모여서 하나의 **Function**(함수)이 되고, 함수들이 호출 및 피호출 관계로 **Bind**(연결)되면서 하나의 프로그램이 완성된다.

<br>

## 연산자 우선순위

- 연산자에는 정해진 우선순위가 있고, 그 우선순위에 따라서 순차적으로 연산을 한다
- **결합성**: 연산자의 우선순위가 같을 때 **왼→오**, **오→왼** 중 어느 쪽을 먼저 연산할 것인지 나타내는 속성

<br>

## 임시결과

- `3 + 4 + 5` → `7 + 5` 가 될 때, 7은 3+4의 결과인 **임시결과**가 된다.
- `7 + 5`의 연산 이후에는 7의 값이 필요 없으므로 자동으로 삭제된다.
- 따라서 만약 중간과정의 결과가 필요하다면 따로 변수에 저장해야 한다.

<br>

## 단순대입 연산자 =

> Copy & Overwrite

`l-value = r-value`

- **left, location-value** (위치 지정자)에, **right-value**에 해당하는 상수를 복사해서 덮어쓴다.
- r-value 자리에 변수가 오면, 해당 변수 메모리의 Data를 참조하여 복사한 후 덮어쓴다.

<br>

## 이항자료 간의 연산 및 승격 = Type Promotion
>표현범위가 큰 형식이 이긴다.

ex) ‘A’ + 1 = `char` + `int` = 표현 범위가 더 큰 `int`값이 결과로 나온다

ex) 123.45 + 1 = `double` + `int` = 표현 범위가 더 큰 `double`값이 결과로 나온다

<br>

## 형변환 연산자 = Type Cast
>피연산자의 자료형을 새로운 자료형으로 변경하는 단항 연산자 (우선순위가 가장 높다)

형변환의 핵심은 **'강제성'**

- 남용 또는 오용 시, 정보를 해석하기가 어렵고 왜곡될 수 있으므로 주의

<br>

## sizeof()

1. **Compile time 연산자**
    - 실행파일을 만들기 전, compile을 할 때 미리 계산을 하므로 아무리 많이 사용해도 CPU의 부하가 안 올라간다.
    → 자주 사용하는 것이 좋다.
2. **피연산자는 자료형, 반환 값은 byte 단위**
    - `sizeof(DataType)`
    - ex) `sizeof(1) == 4` / `sizeof(‘1’) == 1` / `sizeof(1 + 1.2) == 8`
3. **배열의 연산에서 sizeof의 역할이 중요**
    - 배열의 크기는 언제나 변동될 수 있기 때문에, 유지보수의 측면에서 중요하다

<br>

## 주요 연산 특징

1. **관계연산**
    - 문자열처럼 배열형태의 정보에 대한 관계 연산을 수행하고 싶을 때는 전용함수를 이용 : `memcmp()`, `strcmp()`
    - ***주의)*** 실수에 대해서는 절대로 상등이나, 부등연산을 수행하지 말 것! → 부정확한 연산이 이루어진다.


2. **논리연산**
    > **Short Circuit**

    - 논리 연산은 Left → Right로 이루어진다
    - 중간에 안해도 되는 연산은 생략하고 바로 결과를 도출한다.
    - 따라서 쉬운연산, 자주 적중하는 조건을 왼쪽에 배치하는 것이 성능의 측면에서 좋다.

3. **조건연산자 → 3항 연산자**

    > `Condition ? A : B`

    - 조건식이 참이면 A를 선택하고, 거짓이면 B를 선택한다
    - 선택의 대상인 A,B는 모두 **항**이다!